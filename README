// vim:set ts=8 sts=2 sw=2 noet ai ff=unix:

A Sinatra + JRuby app to mock simple http services.

Just a prototype.


Match Behaviour:

Rules may contain various JSON object keys which control how the
rules behave.

Rules must contain a key named "strings", which must be a JSON
array of strings. All the strings specified here must be present
in the request entity (POST body).
Special case: If the list has only item, the string "default", this
is taken to mean a positive match.

rule:
	content_encoding	# ('UTF-8')
	content_type		# (MIME - 'application/json; charset=$content_encoding')
	response		# string
	file			# file, opened with $content_encoding
	service | tunnel	# tunnel to backend

Response data for a given request may be provided directly in the
JSON, if specified as the value of a key named "response".

A response can be kept in a file and its name may be referenced as
the value of a key named "file".
Note that such files should be in UTF-8.

A rule may have a key named "service", with its value being a URI
to a http service. In this case, the request will be POSTed to that
service, and its response will be sent back to the client.

The existence of these keys are checked in the above order.

For "response" and "file", the JSON should contain a key named
"content_type" that specifies a valid MIME type.

Any rule may contain a key named "path_info". If specified, the
path_info used when POSTing to Alecto must end with the value of
"path_info" specified in the rule.
If path_info is specified in a rule, but does not match the
path_info in the http request, the match is considered to have
failed. Note that this occurs before the body content string
comparison.

Combined with "default", "path_info" can be used to set up a real
service to serve most requests, leaving us free to intercept the
(hopefully few) requests we are interested in.


Rules

Are loaded from the file "rules.json" in the current directory.

Example:

{
    "rules": [
        {
            "number": 1,
            "description": "Rule number one",
            "strings": [ "xml", "uid", "gid" ],
            "content_type": "application/xml;charset=UTF-8",
            "response": "<noxmltoday/>"
        },
        {
            "number": 2,
            "description": "Rule the second",
            "strings": [ "foo", "bar", "baz" ],
            "content_type": "application/xml;charset=UTF-8",
            "file": "/etc/baz"
        },
        {
            "number": 3,
            "description": "The Third Rule",
            "path_info": "/v1/customer",
            "strings": [ "default" ],
            "service": "http://host3.example.com/open/v1/customer"
        }
    ]
}


For now, this file is loaded at each request to Alecto. Rule changes
come into effect at the beginning of each request, without requiring
restarting Alecto. This behaviour may or may not change in the future.

